# 검색 기능 구현에서 겪은 어려움과 해결 과정

팀 블로그 프로젝트에서 태그(tag) 기반 검색 기능을 구현하는 것이 어려운 도전 과제였습니다. 특히, 사용자가 입력한 검색어를 어떻게 효율적으로 백엔드에서 처리하고, 데이터베이스에서 관련 게시글과 사용자를 조인(join)하여 가져올지에 대한 초기 설계 단계에서 고민이 필요했습니다. 단순히 데이터를 불러오는 것을 넘어, 사용자에게 시각적으로 명확하게 구분된 검색 결과를 제공하는 것 또한 중요한 목표였습니다.

## 문제 해결을 위한 접근 방식

-   RESTful API 설계 및 검색어 처리
    URL 파라미터를 통해 검색어를 받아들이는 RESTful API를 설계했습니다. **@Get(':q')** 데코레이터를 사용하여 검색어를 컨트롤러로 전달하고, 이를 기반으로 검색 로직을 실행하도록 구현하여, 백엔드와 프론트엔드의 연결을 명확하게 데이터 교환의 효율성을 높였습니다.

**@Query('q') query: string** 입력방법을 알고 이 query를 통해 관련 게시글과 유저를 반환하게 해야겠다라고 생각하였습니다.

프론트엔드에서 게시글과 사용자를 명확하게 구분하여 UI를 구성할 수 있도록, SearchResponseDto를 정의하여 **posts**와 **users** 객체를 각각 반환했습니다. 이로써 프론트엔드 개발자가 데이터를 쉽게 활용할 수 있습니다.

```ts
export class SearchResponseDto {
    posts: PostCardDto[];
    users: PublicUser[];
}
```

searchByTag()함수는 query로 posts와 users를 return {posts, users} 객체로 반환합니다.

## 데이터 중복 처리 및 가공

**posts** 경우는 transformToPublicPostDto() 함수를 사용하여 게시글을 공용 정보로 가공했습니다. 이 과정에서 게시글의 작성자인 EditorRole.OWNER와 EditorRole.EDITOR를 식별하고, 이들의 정보를 toPublicUser() 메서드로 변환하여 authors 배열에 담았습니다. 이 배열에는 다른 사용자가 확인할 수 있는 공개된 정보만 포함됩니다.

**users** 경우는 검색된 데이터 중 중복되는 사용자 정보가 발생하는 문제를 해결하는 데 중점을 두었습니다. 한 사용자가 여러 게시글을 작성할 수 있어 중복된 사용자 데이터가 생길 수 있었기 때문입니다. 이를 해결하기 위해 Map 객체를 활용하여 게시글 작성자들(authors)을 순회하면서 고유한 사용자 목록인 **uniqueUsers**를 효율적으로 생성했습니다, toPublicUser() 메서드를 사용하여 최종적으로 사용자에게 필요한 공개 정보만 포함된 데이터로 가공하여 반환했습니다.

## 마무리

복잡한 데이터 관계를 효율적으로 처리하기 위해 TypeORM을 활용한 JOIN 쿼리를 설계하고, 트랜잭션을 적용해 데이터의 일관성을 확보하는 과정에서 백엔드 개발의 핵심 원리를 깊이 있게 이해할 수 있었습니다.
