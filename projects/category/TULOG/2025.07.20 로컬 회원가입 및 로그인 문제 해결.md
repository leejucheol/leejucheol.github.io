# 로컬 회원가입 및 로그인 문제 해결

사용자가 Google 인증이 아닌 로컬 방식으로 회원가입을 시도할 때, 백엔드에서 이메일로 인증 코드를 보내고 이를 확인하는 과정을 로컬 로그인으로 구현하였습니다.
아이디와 비밀번호 예외처리를 진행하고 로그인을 진행하면 토큰을 받아 해당 웹을 이용할 수 있습니다.

## 어떤 문제를 직면했냐면요

-   단순하게 관리자 이메일로 회원가입 요청하는 사용자 이메일로 인증번호를 제공하고 받은 코드를 인증하는 부분에서 어떻게 인증해야하는지 부분에서 맞닿았습니다.
-   sendEmailCode와 verifyEmailCode 함수는 emailCodeStore라는 Map 객체를 사용하여 인증 코드를 관리합니다. 이 두 방식은 서로 독립적으로 작동하며, 코드의 통일성을 해치고 로직을 복잡하게 만듭니다.
-   또한 sendEmailCode 함수를 통해 전송된 인증 코드가 언제 만료되는지 명확하게 관리되지 않으며, 동일한 코드인지 탐색하는 경우도 불분명했습니다.

## 개선된 흐름으로는요

1단계: signup 함수 호출

회원가입 요청이 오면, 사용자의 이메일과 닉네임 중복을 확인합니다.

이메일 중복이 아닌 경우, pendingUserRepository에 사용자의 임시 정보를 저장합니다. 이 때, 인증 코드와 만료 시간을 함께 저장합니다.

저장이 성공하면, nodemailer를 사용하여 이메일로 인증 코드를 전송합니다.

2단계: completeSignup 함수 호출

사용자가 받은 인증 코드를 입력하여 회원가입 완료를 요청합니다.

completeSignup 함수는 pendingUserRepository에서 해당 이메일과 코드가 일치하는지 확인합니다.

이때, codeExpiresAt을 현재 시간과 비교하여 인증 코드가 만료되었는지 검증합니다.

3단계: 모든 검증이 통과하면, pendingUserRepository의 데이터를 기반으로 실제 User와 Auth 레코드를 생성하고, pendingUser 데이터를 삭제합니다.

이 과정은 데이터 일관성을 보장하기 위해 트랜잭션으로 묶어야 합니다. pendingUser는 단지 임시저장된 유저이고 이는 인증할때만 사용할 것이기에 가입이 완료되면 삭제되게 구현하였습니다.

## 마무리

이번 프로젝트를 통해 이론을 실제 코드에 적용하며 문제를 해결하는 과정을 깊이 있게 배웠습니다. 특히 팀원과 함께 **nodemailer**를 활용한 인증 메일 발송 로직과 **bcrypt**를 사용한 비밀번호 암호화를 구현하며, 서버 환경에 안정적인 인증 시스템을 구축하는 것의 중요성을 깨달았습니다. 앞으로도 새로운 도전과 배움을 통해 성장할 것입니다.
